We now know that we are in a docker container. Since we know that we are in a docker container, we can continue with situation awareness and enumeration to determine what we can do and what other paths we can take to continue attacking this server. A critical part of situational awareness is identifying network and host information. This can be done via port scanning and network tooling.  

In this task, we will be covering using what we have at our disposal in a limited environment to gain information and awareness of the environment. We will showcase both bash and python port scanners that you can utilize as both are common to have inside of a system or container and other tricks that can be used, such as Netcat and statically compiled binaries.  

The first method of port scanning we will be covering is using bash. In bash, we can utilize `/dev/tcp/ipaddr/port`; this will act as a built-in scanner to gather information on the container ports. This utility is broken down below.  

- `/dev/` contains all hardware devices, such as NIC, HDD, SSD, RAM
- `/dev/tcp/` pseudo-device of your ethernet/wireless card opens a socket when data is directed either in or out.

For more information about this, check out the Linux Documentation Project. [https://tldp.org/LDP/abs/html/devref1.html](https://tldp.org/LDP/abs/html/devref1.html)  

We can use this to our advantage to scan internal ports by piping a list of ports into it. Find an example of a full bash port scanner below.  

`#!/bin/bash   ports=(21 22 53 80 443 3306 8443 8080)   for port in ${ports[@]}; do   timeout 1 bash -c "echo \"Port Scan Test\" > /dev/tcp/1.1.1.1/$port && echo $port is open || /dev/null"    done`

The second method of port scanning we will cover is using python. To scan ports with python, we will need to use the `sockets` library to open connections and enable network connectivity. The script itself is as simple as opening connections to sequencing ports in a loop. Find an example of the full python port scanner below.  

`#!/usr/bin/python3   import socket   host = "1.1.1.1"   portList = [21,22,53,80,443,3306,8443,8080]   for port in portList:    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    try:     s.connect((host,port))     print("Port ", port, " is open")    except:     print("Port ", port, " is closed")`

The mainline of code doing all the work is `socket.AF_INET, socket.SOCK_STREAM` this will be a precursor to opening a connection to the specified host and port.

The third method we will look at is unique and uses Netcat to connect to a range of ports. Netcat is a reasonably common utility on all Linux boxes, so it is safe to assume that we will always have it at our disposal. Find example syntax below.  

Syntax: `nc -zv 192.168.100.1 1-65535`

Along with these living off-the-land scripts, we can also utilize statically compiled binaries. A statically compiled binary is similar to any other binary with all libraries and dependencies included in the binary. This makes it so that you can run the binary on any system with the same architecture (x86, x64, ARM, etc). There are several places that you can download these binaries and compile them yourselves. Check out this GitHub for a list of stable binaries. [https://github.com/andrew-d/static-binaries](https://github.com/andrew-d/static-binaries).


---

## Understanding where you are

- You compromised a webapp `10.200.95.33`.
- From there we got a shell in a Docker Container `192.168.100.100` . 
- This Container uses `192.168.100.1` as the Gateway, so the device there can talk to outside world. 
- You can try to ping this Container or the Gateway but we can’t from our Attack Machine, so we can’t talk to this `192.168.100.0/24` subnet. 
- But what happens if you try to connect to your Attack Machine from this Container?
	- To test, open a port in the Attack Machine with `nc -lnvp 11000` and connecteto it from the Container with `nc <Attack_IP> 11000` .  You can ! That means as your IP `10.50.74.165` is not in the Container routing table, the Container uses the Default Gateway `192.168.100.1` to talk back to us and it can access us.


---

# Your job

## IP

You can also check the IP address and see indeed the network interface `eth0` has a different IP `192.168.100.100` .

![[Task - 15 Docker? I hardly even know her!-20240909134102884.webp]]


## How does this Address communicate to the outside network ?

Run route command on the shell.

www-data@85da888a9d5c:/tmp$`route`

![[Task - 15 Docker? I hardly even know her!-20240909134455466.webp]]

The output says: 
- If the packets needs to get to the network 192.168.100.0/24, directly send them to that computer, no requirement for a gateway. That means this `192.168.100.0/24` is the local network. 
- IP is `192.168.100.100` so it makes sense. 
- It also says if the destination is anyplace other than `192.168.100.0/24` , the packets should take the default Gateway. Now the default gateway is not fully written here. To check that let’s execute `arp -a` and see the results.

	www-data@85da888a9d5c:/tmp$ `arp -a`
	![[Task - 15 Docker? I hardly even know her!-20240909135055611.webp]]

Here you see the default gateway is `192.168.100.1` , now what does a Gateway mean ? 
The gateway is just another device on the network that has the capability to talk to devices outside this local network. In our home networks, usually the router is the default gateway because it can forward our local packets to outside world if we need.

## Internal Network Enumeration (192.168.0.1) with netcat

www-data@276ba513f469:/proc/1$ `nc -zv 192.168.100.1 1-65535`


This uses **Netcat (nc)** to scan the ports on the target IP address (`192.168.100.1`) across the entire port range (`1-65535`). Here's a breakdown of the options:

- `-z`: Zero I/O mode, useful for scanning. It doesn't send any data to the target, just checks if a port is open.
- `-v`: Verbose mode, which means the command will give more detailed output (whether a port is open or closed).
- `192.168.100.1`: The target IP address you are scanning.
- `1-65535`: The range of ports to scan, from port 1 to 65535 (the full range of TCP/UDP ports).

	![[Task - 15 Docker? I hardly even know her!-20240909151319865.webp]]


---

## Answer the questions below

> What is the Default Gateway for the Docker Container?
> `192.168.100.1`

> What is the high web port open in the container gateway?
> `8080`

> What is the low database port open in the container gateway?
> `3306`

**Next step:** [[Task 17 - Dorkus Storkus - Protector of the Database]]
